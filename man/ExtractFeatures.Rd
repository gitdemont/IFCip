% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ExtractFeatures.R
\name{ExtractFeatures}
\alias{ExtractFeatures}
\title{Features Extraction}
\usage{
ExtractFeatures(
  ...,
  objects,
  offsets,
  removal = "masked",
  display_progress = TRUE,
  nmax = 9,
  granularity = 3,
  batch = 20,
  parallel = FALSE
)
}
\arguments{
\item{...}{arguments to be passed to \code{\link{objectExtract}} with the exception of 'ifd' and 'bypass'(=TRUE).\cr
If 'param' is provided 'export'(="matrix"), 'mode'(="raw"), 'size'(="c(0,0)"), 'force_width'(="FALSE") and 'removal' will be overwritten.\cr
If 'offsets' are not provided extra arguments can also be passed with ... to \code{\link{getOffsets}}.\cr
/!\ If not any of 'fileName', 'info' and 'param' can be found in ... then attr(offsets, "fileName_image") will be used as 'fileName' input parameter to pass to \code{\link{objectParam}}.}

\item{objects}{integers, indices of objects to use.
This argument is not mandatory, if missing, the default, all objects will be used.}

\item{offsets}{object of class `IFC_offset`. 
This argument is not mandatory but it may allow to save time for repeated image export on same file.}

\item{removal}{whether to compute features on "masked" object fo each individual channels or on the globally detected object "MC".
Allowed are "masked" or "MC". Default is "masked". Please note that it will overwrite 'param' value if provided.}

\item{display_progress}{whether to display a progress bar. Default is TRUE.}

\item{nmax}{maximal order of Zernike polynomials to be computed. Default value is 9. Values outside [0,99] will be clipped.
Be aware that computation of Zernike's Moments can be quite long when 'nmax' is high.}

\item{granularity}{an integer vector. Controls the grain of the Haralick texture. Default is 3. Allowed are [1-20].
For very fine textures, this value is small (1-3 pixels), while for very coarse textures, it is large (>10).}

\item{batch}{number of objects to process at the same time. Default is 20.}

\item{parallel}{whether to use parallelization. Default is FALSE. Note that parallelization requires a parallel backend to be registered (see example).
In addition when parallelization is possible display_progress will be turned to FALSE.}
}
\value{
a 3D array of features values whose dimensions are [object, features, channel].
}
\description{
Function to extract features from objects stored within rif and cif files.
}
\details{
arguments of objectExtract() from IFC package will be deduced from \code{\link{ExtractFeatures}} input arguments.
}
\examples{
msg_dat = character()
msg_par = character()
if(!requireNamespace("IFCdata", quietly = TRUE)) msg_dat = "IFCdata"
if(!requireNamespace("parallel", quietly = TRUE)) msg_par = c(msg_par, "parallel")
if(!requireNamespace("doParallel", quietly = TRUE)) msg_par = c(msg_par, "doParallel")
if(!requireNamespace("foreach", quietly = TRUE)) msg_par = c(msg_par, "foreach")
if(length(msg_dat) == 0) {
  ## use a cif file
  file_cif <- system.file("extdata", package = "IFCdata", "example.cif")
  ## features extraction
  ## the extraction is run for only objects 1 to 50 to allow example to run 
  ## in a reasonable amount of time to fulfill CRAN policies
  ## in current usage 'objects' argument may be missing to allow features extraction for all objects
  time_seq <- system.time({
    feat_seq <- ExtractFeatures(fileName = file_cif, 
                                objects = 1:50,
                                display_progress = TRUE,
                                parallel = FALSE)
  })
  if(length(msg_par) == 0) {
    ## same extraction with a parallel backend,
    ## use of parallelization can clearly speed up the process,
    ## notably when Zernike features are extracted on a large amount of objects
    ## here is a small example that requires 'parallel', 'doParallel', and 'foreach' packages
    ## not installed along with 'IFCip' package
    library(parallel)
    library(doParallel)
    library(foreach)
    no_cores <- max(1, parallel::detectCores() - 1)
    ## the following is for R CMD cran check which allows to use at most 2 cores
    if("TRUE" \%in\% Sys.getenv("_R_CHECK_LIMIT_CORES_", "")) no_cores = min(2, no_cores)
    cl <- parallel::makePSOCKcluster(no_cores)
    doParallel::registerDoParallel(cl)
    time_par <- system.time({
       feat_par <- ExtractFeatures(fileName = file_cif, 
                                   objects = 1:50, 
                                   display_progress = TRUE, 
                                   parallel = TRUE)
    })
    parallel::stopCluster(cl)
    foreach::registerDoSEQ()
  } else {
    message(sprintf('Please run `install.packages(\%s)` \%s',
                    paste0("c(", paste0('"',msg_par,'"', collapse = ", "), ")"),
                   'to use parallelization.'))
  }
} else {
  message(paste0(sprintf('Please run `install.packages("IFCdata",repos="\%s",type="source")` \%s',
                 'https://gitdemont.github.io/IFCdata/',
                 'to install extra files required to run this example.'),
                 ifelse(length(msg_par) == 0, "" ,
                        sprintf('Please run `install.packages(\%s)` \%s',
                                paste0("c(", paste0('"',msg_par,'"', collapse = ", "),")"),
                               'to use example of features extraction with parallelization.'))))
}
}
