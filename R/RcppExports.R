# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Image Background
#' @name cpp_background
#' @description
#' This function is designed to compute image background on a "raw" image
#' @param img a NumericMatrix, containing image intensity values.
#' @param margin R_len_t number of rows margin used to compute background. Default is 4.
#' @param extra R_len_t number of extra columns used to compute background. Default is 0.
#' @param is_cif a bool whether 'ímg' originates from a cif_file or not. Default is false.
#' @return a NumericVector of background mean and sd
#' @keywords internal
NULL

#' @title Antipodal Pairs of Convex Hull
#' @name cpp_antipodalpairs
#' @description
#' Computes antipodal pairs of a convex polygon 
#' @param pts a 2-column matrix defining the locations (x and y coordinates, respectively) of points.
#' It has to be an object of class `IFCip_convexhull`
#' @source Adaptation from \url{https://escholarship.mcgill.ca/concern/theses/fx719p46g} in Computational geometry with the rotating calipers authored by Pirzadeh, Hormoz under supervision of Toussaint, Godfried T. at McGill University.
#' @return an IntegerVector of antipodal pairs of the convex input polygon. Note that this vector of indices is in C so 1st start at 0; add 1 to use it in R.
#' @keywords internal
NULL

#' @title Bounding Box of Convex Hull
#' @name cpp_bbox
#' @description
#' Computes features from a Convex Hull 
#' @param pts a 2-column matrix defining the locations (x and y coordinates, respectively) of points.
#' It has to be an object of class `IFCip_convexhull`
#' @param scale a double used to scale the returned values.
#' @return a NumericVector of features from convex hull.
#' @keywords internal
NULL

#' @title Image Scaling
#' @name cpp_rescale
#' @description
#' This function is designed to scale a SEXP to [0, n_lev - 1]
#' @param img, a SEXP (logical, raw, integer or numeric) vector or matrix containing image intensity values.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @param value, a double; it is the replacement value that will be used when 'msk' element is false. Default is NA_REAL.
#' @param n_lev, an int determining the number of levels used for the computation. Default is 256.
#' @param invert, a bool determining whether 'img' should be scaled from min to max (when false, [min(img),max(img)] becoming [0,n_lev-1]) or inverted (when true, with [max(img),min(img)] rescaled to [0,n_lev-1]) values. Default is false.
#' @param bin, a bool determining whether 'img' should be binned or if scaling should be continuous. Default is true to return discrete values.
#' @details when 'msk' is provided it has to be of the same dimensions as 'img', otherwise an error will be thrown.\cr
#' an error will be thrown also if 'msk' contains non-finite value.\cr
#' 'img' range will be determined based on indices of non 0 'msk' values and only the values in 'img' at those indices will be scaled; the others will be filled with 'value'.
#' @return a SEXP of same type as 'img' with class `IFCip_rescale`
#' @keywords internal
NULL

#' @title Image Reverse Scaling
#' @name cpp_scalerev
#' @description
#' This function is designed to revert scaling of a SEXP
#' @param img, a SEXP (logical, raw, integer or numeric) vector or matrix containing image intensity values.
#' @param sca, a Rcpp::NumericVector of length 5 containing scaling information. Default is R_NilValue to use attr(img, "scale").
#' @return a SEXP of same type as 'img'
#' @keywords internal
NULL

#' @title Haralick Co-occurrence Matrix
#' @name cpp_cooc
#' @description
#' This function is designed to compute Haralick co-occurrence matrix
#' @param img a Rcpp::IntegerMatrix of class `IFCip_rescale`, containing image intensity values.
#' @param delta a Rcpp::IntegerVector of column and row shifts. If only one value is provided only row will be shifted.
#' @details See 'Textural Features for Image Classification', Haralick et. al (1979),
#' available at: \url{https://haralick.org/journals/TexturalFeatures.pdf}
#' @return a Rcpp::IntegerMatrix Gray-Level Co-occurrence Matrices.
#' @keywords internal
NULL

#' @title Haralick Features
#' @name cpp_h_features
#' @description
#' This function is designed to compute Haralick's features
#' @param cooc a Rcpp::NumericMatrix of class `IFCip_cooc`, co-occurrence matrix to compute Haralick's features from.
#' @param invariant a bool, whether to compute invariant Haralick's texture features. Default is false.
#' Not yet supported.
#' @details Haralick's invariant texture features are described in Löfstedt T, Brynolfsson P, Asklund T, Nyholm T, Garpebring A (2019) Gray-level invariant Haralick texture features.
#' PLoS ONE 14(2): e0212110. \doi{10.1371/journal.pone.0212110}
#' @return a Rcpp::NumericVector of Haralick's texture features
#' @keywords internal
NULL

#' @title Hu's Centroid
#' @name cpp_centroid
#' @description
#' This function is designed to compute Hu's image centroids.
#' @param img a NumericMatrix, containing image intensity values.
#' @keywords internal
NULL

#' @title Hu's Raw Moment
#' @name cpp_rmoment
#' @description
#' This function is designed to compute Hu's image raw moment.
#' @param img a NumericMatrix, containing image intensity values.
#' @param p uint8_t: p order. Default is 0.
#' @param q uint8_t: q order. Default is 0.
#' @keywords internal
NULL

#' @title Hu's Central Moment
#' @name cpp_cmoment
#' @description
#' This function is designed to compute Hu's image central moment.
#' @param img a NumericMatrix, containing image intensity values.
#' @param cx double, x centroid of the img.
#' @param cy double, y centroid of the img.
#' @param p uint8_t: p order. Default is 0.
#' @param q uint8_t: q order. Default is 0.
#' @keywords internal
NULL

#' @title Hu's Partial Features
#' @name cpp_features_hu1
#' @description
#' This function is designed to compute Hu's central moments.
#' @param img a NumericMatrix, containing image intensity values.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -4.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericVector of Hu's moments values.\cr
#' -Area: img's area\cr
#' -circularity: img's circularity\cr
#' -Minor Axis: img's ellipsis minor axis\cr
#' -Major Axis: img's ellipsis major axis\cr
#' -Aspect Ratio: img's ratio of minor axis over major axis\cr
#' -Angle: img's ellipsis angle with x axis (in radians)\cr
#' -theta: img's ellipsis theta angle (in radians)\cr
#' -Eccentricity: img's ellipsis ecentricity\cr
#' -pix cx: img's pixel x centroïd\cr
#' -pix cy: img's pixel y centroïd\cr
#' -pix min axis: img's ellipsis minor axis in pixels\cr
#' -pix_maj_axis: img's ellipsis major axis in pixels\cr
#' -pix count: img's area in pixels.
#' @keywords internal
NULL

#' @title Hu's Full Features
#' @name cpp_features_hu2
#' @description
#' This function is designed to compute Hu's central moments + 7 invariant moments
#' @param img a NumericMatrix, containing image intensity values.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -4.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericVector of Hu's moments values.\cr
#' -Area: img's area\cr
#' -circularity: img's circularity\cr
#' -Minor Axis: img's ellipsis minor axis\cr
#' -Major Axis: img's ellipsis major axis\cr
#' -Aspect Ratio: img's ratio of minor axis over major axis\cr
#' -Angle: img's ellipsis angle with x axis (in radians)\cr
#' -theta: img's ellipsis theta angle (in radians)\cr
#' -Eccentricity: img's ellipsis ecentricity\cr
#' -pix cx: img's pixel x centroïd\cr
#' -pix cy: img's pixel y centroïd\cr
#' -pix min axis: img's ellipsis minor axis in pixels\cr
#' -pix_maj_axis: img's ellipsis major axis in pixels\cr
#' -pix count: img's area in pixels\cr
#' -inv[1-7]: image invariant moments.
#' @keywords internal
NULL

#' @title Basic Features
#' @name cpp_basic
#' @description
#' This function is designed to compute very basic features based on Hu's moments + intensities.
#' @param img a NumericMatrix, containing image intensity values.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -4.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericVector of basic features values.\cr
#' -Area: msk's area\cr
#' -circularity: msk's circularity\cr
#' -Minor Axis: msk's ellipsis minor axis\cr
#' -Major Axis: msk's ellipsis major axis\cr
#' -Aspect Ratio: msk's ratio of minor_axis over major_axis\cr
#' -Angle: msk's ellipsis angle with x axis (in radians)\cr
#' -theta: msk's ellipsis theta angle (in radians)\cr
#' -eccentricity: msk's ellipsis ecentricity\cr
#' -pix cx: msk's pixel x centroïd\cr
#' -pix cy: msk's pixel y centroïd\cr
#' -pix min_axis: msk's ellipsis minor axis in pixels\cr
#' -pix maj axis: msk's ellipsis major axis in pixels\cr
#' -pix count: msk's area in pixels\cr
#' -Raw Mean Pixel: img's mean pixel intensity\cr
#' -Raw Min Pixel: img's minimal pixel intensity\cr
#' -Raw Max Pixel: img's maximal pixel intensity.
#' @keywords internal
NULL

#' @title Image Features Extraction
#' @name cpp_features_hu3
#' @description
#' This function is designed to compute image features.
#' @param img a NumericMatrix, containing image intensity values.
#' @param msk an IntegerMatrix, containing msk components.
#' @param components an unsigned integer. Maximal component component number to retrieve features about.
#' Default is 0 to retrieve  features for all components.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -4.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericMatrix whose rows are component numbers and columns are:\cr
#' -Area, area of the component\cr
#' -circularity, circularity of the component\cr
#' -Minor Axis, minor axis of the component\cr
#' -Major Axis, major axis of the component\cr
#' -Aspect Ratio, aspect ratio of the component\cr
#' -Angle, angle of the component\cr
#' -theta, theta of the component\cr
#' -eccentricity, eccentricity of the component\cr
#' -Minor Axis Intensity, intensity weighted minor axis of the component\cr
#' -Major Axis Intensity, intensity weighted major axis of the component\cr
#' -Aspect Ratio Intensity, intensity weighted aspect ratio of the component\cr
#' -Angle Intensity, intensity weighted angle of the component\cr
#' -theta intensity, intensity weighted theta of the component\cr
#' -eccentricity intensity, intensity weighted eccentricity of the component\cr
#' -pix cx, x centroid of the component in pixels\cr
#' -pix cy, y centroid of the component in pixels\cr
#' -pix min axis, minor axis of the component in pixels\cr
#' -pix maj axis, major axis of the component in pixels\cr
#' -pix count, number of pixels occupied by the component\cr
#' -inv[1-8], component Hu's invariant moments\cr
#' -Raw Mean Pixel, mean pixels intensity of the component\cr
#' -Raw Min Pixel, pixels intensity minimum of the component\cr
#' -Raw Max Pixel, pixels intensity maximum of the component\cr
#' -Std Dev, pixels intensity standard variation of the component\cr
#' -skewness, component's skewness\cr
#' -kurtosis, component's kurtosis
#' -Centroid Y, scaled Y centroid\cr
#' -Centroid X, scaled X centroid\cr
#' -Centroid Y Intensity, intensity weighted scaled Y centroid\cr
#' -Centroid X Intensity. intensity weighted scaled X centroid.
#' @keywords internal
NULL

#' @title Otsu Multi Thresholding
#' @name cpp_multi_otsu
#' @description
#' This function determines best threshold(s) according to Otsu's method.
#' @param img, a NumericVector.
#' @param msk_, a NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @param n_comp, number of components to separate. Default is 2, should be at least 2.\cr
#' Returned thresholds will be of length n_comp - 1.
#' @param n_lev, an unsigned short determining the number of grey levels used for the computation. Default is 256, should be at least 2.
#' Despite being fast thanks to LUT pre-computation, performance will be highly impacted with large 'n_comp' or 'n_lev' values (typically n_comp = 5 and n_lev = 256).
#' Alternatively, you can try to decrease 'n_lev' when 'n_comp' needs to be large (e.g. n_comp = 8 and n_lev = 32).
#' @details adaptation of 'A Fast Algorithm for Multilevel Thresholding' from L. Ping-Sung, C. Tse-Sheng, and C. Pau-Choo
#' in Jounal of Information Science and Engineering. 2001(17), 713-727.
#' \doi{10.6688/JISE.2001.17.5.1}
#' @return an NumericVector of threshold(s).
#' @keywords internal
NULL

#' @title Mask Euclidean Distance
#' @name cpp_distance_eucl
#' @description
#' This function is designed to compute Euclidean distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return an NumericMatrix.
#' @keywords internal
NULL

#' @title Mask Normalized Euclidean Distance
#' @name cpp_distance_eucl_norm
#' @description
#' This function is designed to compute normalized Euclidean distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Mask Manhattan Distance
#' @name cpp_distance_manh
#' @description
#' This function is designed to compute Manhattan distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Mask Normalized Manhattan Distance
#' @name cpp_distance_manh_norm
#' @description
#' This function is designed to compute normalized Manhattan distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return an NumericMatrix.
#' @keywords internal
NULL

#' @title Manhattan Distance Transform
#' @name cpp_disttrans_manh
#' @description
#' This function computes the Manhattan distance transform of an image by implementing A. Meijster algorithm.
#' @param img, a NumericMatrix.
#' @details adaptation of 'A General Algorithm For Computing Distance Transforms In Linear Time' from W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink.
#' Mathematical Morphology and its Applications to Image and Signal Processing. February 2002, Pages 331-340.\doi{10.1007/0-306-47025-X_36}\cr
#' Values > 0 will be considered as foreground whereas all other values will be concidered as background (i.e. 0).
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Euclidean Distance Transform
#' @name cpp_disttrans_eucl
#' @description
#' This function computes the Euclidean distance transform of an image by implementing A. Meijster algorithm.
#' @param img, a NumericMatrix.
#' @details adaptation of 'A General Algorithm For Computing Distance Transforms In Linear Time' from W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink.
#' Mathematical Morphology and its Applications to Image and Signal Processing. February 2002, Pages 331-340.\doi{10.1007/0-306-47025-X_36}\cr
#' Values > 0 will be considered as foreground whereas all other values will be concidered as background (i.e. 0).
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Euclidean Voronoï
#' @name cpp_voronoi_eucl
#' @description
#' This function computes Voronoï diagram using Euclidean distance of a seed image.
#' @param img, a positive IntegerMatrix where values > 0 represent foreground seeds.
#' @details img will be passed to connected component labelling and centroïd of each identified components will be used to build Voronoï diagram.
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Manhattan Voronoï
#' @name cpp_voronoi_manh
#' @description
#' This function computes Voronoï diagram using Manhattan distance of a seed image.
#' @param img, a positive IntegerMatrix where values > 0 represent foreground seeds.
#' @details img will be passed to connected component labelling and centroïd of each identified components will be used to build Voronoï diagram.
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Zernike's Features
#' @name cpp_zernike1
#' @description
#' This function is designed to compute Zernike's moments from image.
#' It will compute Zernike's moments but will not return image projection.
#' @param img a NumericMatrix, containing image intensity values.
#' @param msk_ a Nullable LogicalMatrix. Default is R_NilValue.
#' @param cx a double. X centroid. Default is 0.0.
#' @param cy a double. Y centroid. Default is 0.0.
#' @param zmax a uint8_t, maximal order of Zernike polynomials to be computed. Default is 15. Values outside [0,99] will be clipped.
#' Be aware that computation of Zernike's moments can be quite long when 'zmax' is high.
#' @param radius a numeric, radius of the circle in pixels around object centers from which the features are calculated. Default is 15.
#' @source Adaptation from \url{https://github.com/aoles/EBImage} in v3.12.0, authored by Andrzej Oles, Gregoire Pau, Mike Smith, Oleg Sklyar, Wolfgang Huber, with contributions from Joseph Barry and Philip A. Marais \email{andrzej.oles@embl.de}.
#' @keywords internal
NULL

#' @title Zernike's Features with Projections
#' @name cpp_zernike2
#' @description
#' This function is designed to compute Zernike's moments from image.
#' It will compute Zernike's moments but also return image projection.
#' @param img a NumericMatrix, containing image intensity values.
#' @param msk_ a Nullable LogicalMatrix. Default is R_NilValue.
#' @param cx a double. X centroid. Default is 0.0.
#' @param cy a double. Y centroid. Default is 0.0.
#' @param zmax a uint8_t, maximal order of Zernike polynomials to be computed. Default is 15. Values outside [0,99] will be clipped.
#' Be aware that computation of Zernike's moments can be quite long when 'zmax' is high.
#' @param radius a numeric, radius of the circle in pixels around object centers from which the features are calculated. Default is 15.
#' @source Adaptation from \url{https://github.com/aoles/EBImage} in v3.12.0, authored by Andrzej Oles, Gregoire Pau, Mike Smith, Oleg Sklyar, Wolfgang Huber, with contributions from Joseph Barry and Philip A. Marais \email{andrzej.oles@embl.de}.
#' @keywords internal
NULL

#' @title Matrix List AND Logic
#' @name cpp_AND_M
#' @description
#' This function takes a list of matrices and returns the AND operation applied on these matrices.
#' @param list a list of logical matrices.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix List OR Logic
#' @name cpp_OR_M
#' @description
#' This function takes a list of matrices and returns the OR operation applied on these matrices.
#' @param list a list of logical matrices.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Neg Logic
#' @name cpp_NEG_M
#' @description
#' This function takes a logical matrix and returns its negation.
#' @param mat LogicalMatrix.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Logic Equal
#' @name cpp_k_equal_M
#' @description
#' This function takes an NumericMatrix and checks for members equal to k
#' @param mat a NumericMatrix
#' @param k constant to be checked. Default is 3.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Logic Superior and Equal
#' @name cpp_k_sup_equal_M
#' @description
#' This function takes an NumericMatrix and checks for members superior or equal to k
#' @param mat a NumericMatrix
#' @param k constant to be checked. Default is 3.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Logic Inferior and Equal
#' @name cpp_k_inf_equal_M
#' @description
#' This function takes an NumericMatrix and checks for members inferior or equal to k
#' @param mat a NumericMatrix
#' @param k constant to be checked. Default is 3.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Image Shift
#' @name cpp_shift
#' @description
#' Function that shifts mat according to d_row and d_col parameters
#' @param mat a numeric matrix.
#' @param d_row an integer, giving row shift. Default is 0 for no change.
#' @param d_col an integer, giving col shift. Default is 0 for no change.
#' @param add_noise logical, if true adds normal noise when at least one new dimension is larger than original mat dimensions
#' Rcpp::rnorm() function is used. Default is true.
#' @param bg double, mean value of the background added if add_noise is true. Default is 0.
#' @param sd double, standard deviation of the background added if add_noise is true. Default is 0.
#' @return a shifted matrix with additional rows/columns if d_row or d_col are different from 0.
#' @keywords internal
NULL

#' @title Image Flip
#' @name cpp_flip
#' @description
#' Function that flips mat 
#' @param mat NumericMatrix.
#' @param which bool. Default is true. Use true to flip horizontally and false vertically.
#' @return a flipped matrix.
#' @keywords internal
NULL

#' @title Image Padding
#' @name cpp_padding
#' @description
#' This function creates a new matrix with extra rows / cols according to input mat, kernel
#' @param mat, a NumericMatrix.
#' @param extra_rows,extra_cols number of extra rows and/or columns to add. Default is 0.
#' @param method, a uint8_t. Default is 1, allowed are [1-8].\cr
#' -1, extra cols / rows will be filled with 'k', returned 'out' will not be filled.\cr
#' -2, extra cols / rows will be filled with the closest col / row, returned 'out' will not be filled.\cr
#' -3, extra cols / rows will be filled mirroring neighbor cols / rows, returned 'out' will not be filled.\cr
#' -4, extra cols / rows will be filled repeating neighbor cols / rows, returned 'out' will not be filled.\cr
#' -5, extra cols / rows will be filled with 'k', returned 'out' will be filled with mat.\cr
#' -6, extra cols / rows will be filled with the closest col / row, returned 'out' will be filled with mat.\cr
#' -7, extra cols / rows will be filled mirroring neighbor cols / rows, returned 'out' will be filled with mat.\cr
#' -8, extra cols / rows will be filled repeating neighbor cols / rows, returned 'out' will be filled with mat.
#' @param k, a double, constant used when method is 1 or 5. Default is 0.0.
#' @return a NumericMatrix, with extra cols / rows
#' @keywords internal
NULL

#' @title Image Filtering
#' @name cpp_filter
#' @description
#' This function applies filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{NA_REAL}.
#' @param what, type of filtering, s std::string. Default is \code{""}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Standard Deviation Filtering
#' @name cpp_sd
#' @description
#' This function applies standard deviation filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{NA_REAL}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Mean Filtering
#' @name cpp_mean
#' @description
#' This function applies mean filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{NA_REAL}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Median Filtering
#' @name cpp_median
#' @description
#' This function applies median filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{NA_REAL}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Mode Filtering
#' @name cpp_mode
#' @description
#' This function applies mode filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{NA_REAL}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Mid Filtering
#' @name cpp_mid
#' @description
#' This function applies mid filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{NA_REAL}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Filtering by Convolution
#' @name cpp_convolve2d
#' @description
#' This function applies 2D convolution filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{0.0}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Filtering by Correlation
#' @name cpp_correlate2d
#' @description
#' This function applies 2D correlation filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method used for padding, a uint8_t. Default is \code{5}, allowed are [1-8].
#' @param k, constant used for padding, a double. Default is \code{0.0}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Urbach-Wilkinson Algorithm for Image Erosion and Dilation
#' @name cpp_uw
#' @description
#' This function applies erosion or dilatation on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param erode, a bool. whether to do image erosion or dilatation. Default is true to perform erosion.
#' @details see 'Efficient 2-D grayscale morphological transformations with arbitrary flat structuring elements' from  E.R. Urbach, M.H.F. Wilkinson.
#' IEEE Transactions on Image Processing, 17(1):1-8, January 2008.\doi{10.1109/tip.2007.912582}
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Erosion
#' @name cpp_erode
#' @description
#' This function applies erosion on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @details see 'Efficient 2-D grayscale morphological transformations with arbitrary flat structuring elements' from  E.R. Urbach, M.H.F. Wilkinson.
#' IEEE Transactions on Image Processing, 17(1):1-8, January 2008.\doi{10.1109/tip.2007.912582}
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Dilatation
#' @name cpp_dilate
#' @description
#' This function applies dilatation on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @details see 'Efficient 2-D grayscale morphological transformations with arbitrary flat structuring elements' from  E.R. Urbach, M.H.F. Wilkinson.
#' IEEE Transactions on Image Processing, 17(1):1-8, January 2008.\doi{10.1109/tip.2007.912582}
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Opening
#' @name cpp_opening
#' @description
#' This function applies opening on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Closing
#' @name cpp_closing
#' @description
#' This function applies closing on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Morphological Gradient
#' @name cpp_gradient
#' @description
#' This function applies morphological gradient on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image White Top Hat
#' @name cpp_tophat_white
#' @description
#' This function applies white top hat on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Black Top Hat
#' @name cpp_tophat_black
#' @description
#' This function applies black top hat on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Self Complementary Top Hat
#' @name cpp_tophat_self
#' @description
#' This function applies self complementary on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Contrast Enhancement
#' @name cpp_cont
#' @description
#' This function applies contrast enhancement on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Laplacian
#' @name cpp_laplacian
#' @description
#' This function applies Laplacian morphology on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Brute Force Image Erosion
#' @name cpp_erosion_old
#' @description
#' This function applies erosion on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time erosion should be iterated. Default is 0.
#' @param msk_, a NumericMatrix with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'mat' elements without masking anything.
#' @details Brute force implementation now replaced by Urbach-Wilkinson algorithm.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Brute Force Image Dilatation
#' @name cpp_dilate_old
#' @description
#' This function applies dilatation on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilatation should be iterated. Default is 0.
#' @param msk_, a NumericMatrix with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'mat' elements without masking anything.
#' @details Brute force implementation now replaced by Urbach-Wilkinson algorithm.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Dilatation Reconstruction
#' @name cpp_rec_dilate
#' @description
#' Performs a dilatation reconstruction of an image.
#' @param markers, a NumericMatrix.
#' @param img, a NumericMatrix.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @details adaptation of 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}
#' @return a NumericMatrix of reconstructed 'img' from 'markers'.
#' @keywords internal
NULL

#' @title Erosion Reconstruction
#' @name cpp_rec_erode
#' @description
#' Performs an erosion reconstruction of an image.
#' @param markers, a NumericMatrix.
#' @param img, a NumericMatrix.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @details adaptation of 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}
#' @return a NumericMatrix of reconstructed 'img' from 'markers'.
#' @keywords internal
NULL

#' @title H-Minima transformation
#' @name cpp_HMIN
#' @description
#' Keep deepest valleys from image.
#' @param img, a NumericMatrix.
#' @param h, a double, specifying the minimal depth. Default is \code{NA_REAL}. When not \code{NA/NaN} it will be used instead of 'h_lev'
#' @param h_lev, an int, specifying the minimal depth normalized to n_lev (being h_lev out of n_lev). Default is \code{1}.
#' @param n_lev, an int determining the number levels used for 'img' rescaling. Default is 65536, should be at least 2.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' HMIN is the erosion reconstruction of (img + h) by kernel.
#' @return a NumericMatrix of H-Minima transformation of 'img'.
#' @keywords internal
NULL

#' @title H-Maxima transformation
#' @name cpp_HMAX
#' @description
#' Keep highest peaks in image.
#' @param img, a NumericMatrix.
#' @param h, a double, specifying the minimal height. Default is \code{NA_REAL}. When not \code{NA/NaN} it will be used instead of 'h_lev'
#' @param h_lev, an int, specifying the minimal height normalized to n_lev (being h_lev out of n_lev). Default is \code{1}.
#' @param n_lev, an int determining the number levels used for 'img' rescaling. Default is 65536, should be at least 2.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' HMAX is the dilatation reconstruction of (img - h) by kernel.
#' @return a NumericMatrix of H-Maxima transformation of 'img'.
#' @keywords internal
NULL

#' @title Regional Minima
#' @name cpp_RMIN
#' @description
#' Mask connected component of pixels whose values are lower to their external boundaries neighborhood.
#' @param img, a NumericMatrix.
#' @param n_lev, an int determining the number levels used for 'img' rescaling. Default is 65536, should be at least 2.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' RMIN is defined as img < HMIN(img, h_lev = 1).
#' @return a NumericMatrix of regional minima of 'img'.
#' @keywords internal
NULL

#' @title Regional Maxima
#' @name cpp_RMAX
#' @description
#' Mask connected component of pixels whose values are higher to their external boundaries neighborhood.
#' @param img, a NumericMatrix.
#' @param n_lev, an int determining the number levels used for 'img' rescaling. Default is 65536, should be at least 2.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' RMAX is defined as img > HMAX(img, h_lev = 1).
#' @return a NumericMatrix of regional maxima of 'img'.
#' @keywords internal
NULL

#' @title Extended Minima
#' @name cpp_EMIN
#' @description
#' Mask the regional minima of the corresponding h-minima transformation.
#' @param img, a NumericMatrix.
#' @param h, a double, specifying the minimal depth. Default is \code{NA_REAL}. When not \code{NA/NaN} it will be used instead of 'h_lev'
#' @param h_lev, an int, specifying the minimal depth normalized to n_lev (being h_lev out of n_lev). Default is \code{1}.
#' @param n_lev, an unsigned short determining the number levels used for 'img' rescaling. Default is 65536, should be at least 2.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' EMIN is defined as RMIN(HMIN(img, h_lev = 1)).
#' @return a NumericMatrix of extended minima of 'img'.
#' @keywords internal
NULL

#' @title Extended Maxima
#' @name cpp_EMAX
#' @description
#' Mask the regional maxima of the corresponding h-maxima transformation.
#' @param img, a NumericMatrix.
#' @param h, a double, specifying the minimal height. Default is \code{NA_REAL}. When not \code{NA/NaN} it will be used instead of 'h_lev'
#' @param h_lev, an int, specifying the minimal height normalized to n_lev (being h_lev out of n_lev). Default is \code{1}.
#' @param n_lev, an unsigned short determining the number levels used for 'img' rescaling. Default is 65536, should be at least 2.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a Rcpp::NumericVector with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'img' elements without masking anything.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' EMAX is defined as RMAX(HMAX(img, h_lev = 1)).
#' @return a NumericMatrix of extended maxima of 'img'.
#' @keywords internal
NULL

#' @title Geodesic White Top Hat
#' @name cpp_geo_tophat_white
#' @description
#' This function applies geodesic white top hat on image.
#' @param img, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' Dilation in closing process is replaced by dilation reconstruction.
#' So, we have out = img - rec_dilate(erode(img)).
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Geodesic Black Top Hat
#' @name cpp_geo_tophat_black
#' @description
#' This function applies geodesic black top hat on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @details see 'Morphological grayscale reconstruction in image analysis: applications and efficient algorithms' from  L. Vincent.
#' IEEE Transactions on Image Processing, 2(2):176-201, April 1993.\doi{10.1109/83.217222}\cr
#' Erosion in opening process is replaced by erosion reconstruction.
#' So, we have out = rec_erode(dilate(img)) - img.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Watershed Transformation SV1
#' @name cpp_watershed_sv1
#' @description
#' This function computes the watershed transformation of an image.
#' @param mat, a NumericMatrix; a distance transform matrix is expected.
#' @param n_lev, an unsigned short determining the number of elevation levels. Default is 256, should be at least 2.
#' @param draw_lines, a bool; whether to draw watershed lines or not. Default is true.
#' @param invert, a bool; whether to fill from basins (lowest values) to peaks (highest values). Default is false.
#' When 'mat' is the result of the distance transformation of an image, peaks (highest values) represent largest distances from background.
#' Thus, they are the ones to be filled first; this can be done with 'invert' set to true.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a NumericMatrix with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'mat' elements without masking anything.
#' @details adaptation of 'Determining watersheds in digital pictures via flooding simulations' from P. Soille. and L. Vincent.
#' In Proc. SPIE 1360, Visual Communications and Image Processing '90: Fifth in a Series, (1 September 1990) \doi{10.1117/12.24211}.
#' @source MorphoLib plugin for ImageJ presents a Java implementation of the algorithm in  \url{https://github.com/ijpb/MorphoLibJ/blob/master/src/main/java/inra/ijpb/watershed/WatershedTransform2D.java} authored by Ignacio Arganda-Carreras 
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Watershed Transformation SV2
#' @name cpp_watershed_sv2
#' @description
#' This function computes the watershed transformation of an image.
#' @param mat, a NumericMatrix; a distance transform matrix is expected.
#' @param n_lev, an unsigned short determining the number of elevation levels. Default is 256, should be at least 2.
#' @param draw_lines, a bool; whether to draw watershed lines or not. Default is true.
#' @param invert, a bool; whether to fill from basins (lowest values) to peaks (highest values). Default is false.
#' When 'mat' is the result of the distance transformation of an image, peaks (highest values) represent largest distances from background.
#' Thus, they are the ones to be filled first; this can be done with 'invert' set to true.
#' @param kernel, a NumericMatrix; the structuring shape determining neighborhood. All non-zero elements will be considered as neighbors (except center).\cr
#' Default is R_NilValue, resulting in 8-connected pixels neighbors computation.
#' @param msk_, a NumericMatrix with finite values. Non-finite values will trigger an error. All non 0 values will be interpreted as true.
#' Default is R_NilValue, for using all 'mat' elements without masking anything.
#' @details adaptation of 'Watersheds in digital spaces: an efficient algorithm based on immersion simulations' from  L. Vincent and P. Soille.
#' In IEEE Transactions on Pattern Analysis and Machine Intelligence, 13(6):583-598, June 1991.\cr
#' @source The algorithm is reviewed in 'The Watershed Transform: Definitions, Algorithms and Parallelization Strategies'
#' from Roerdink, J. B. T. M. and Meijster, A. (2000) in Fundamenta Informaticae, 41, 187-228 \doi{10.3233/FI-2000-411207}
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Contour Tracing Connected Component Labeling
#' @name cpp_ctl
#' @description
#' This function is designed to identify connected component.
#' @param mat a LogicalMatrix, containing mask.
#' @param global whether to compute the perimeter globally or to evaluate the perimeter of each non 8-connected objects. Default is false.
#' When true pixels of overlapping extra borders of objects are counted only once.
#' @details adaptation of 'A linear-time component-labeling algorithm using contour tracing technique' from F. Chang, C.J. Chen and C.J. Lu.
#' Computer Vision and Image Understanding Volume 93, Issue 2, February 2004, Pages 206-220.\doi{10.1016/j.cviu.2003.09.002}
#' @return a list whose members are:\cr
#' -matrix: an IntegerMatrix with connected component labels.\cr
#' -contours: an IntegerMatrix of identified contours, whose columns are x, y, label, direction and type.\cr
#' -nb_lab: the total number of components identified.
#' -perimeter: the number of pixels outside contours.
#' @keywords internal
NULL

#' @title Contours Dilatation
#' @name cpp_dilate_ctl
#' @description
#' This function applies contours dilatation.
#' @param ctl a List, containing contour tracing labeling, object of class `IFCip_ctl`
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Contours Erosion
#' @name cpp_erode_ctl
#' @description
#' This function applies contours erosion.
#' @param ctl a List, containing contour tracing labeling, object of class `IFCip_ctl`
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Polygon Drawing
#' @name cpp_polydraw
#' @description
#' This function is designed to trace and fill polygon inside a matrix.
#' @param poly, a 2-column matrix defining the locations (x and y) of vertices of the polygon of interest.
#' @param border, an int used to trace polygon border.
#' @param fill, an int used to fill polygon.
#' @param tol, a double, tolerance between fill color and connected pixels. Use \code{NA}, for filling every pixel inside 'poly'.
#' @param edge, a bool whether to close 'poly' at 'mat_' edges. Default is \code{false}. Closing 'poly' at 'edge' is experimental and may fail.
#' @param mat_, a NumericMatrix to be filled.\cr
#' When 'mat_' is provided 'poly' will be drawn in 'mat_' if its vertices are within 'mat_' dimensions and if there is no \code{NA} directly (4-connectedness) connected to internal poly' border.\cr
#' /!\ Note that filling will not propagate on \code{NA}, \code{NaN} values, unless 'tol' is \code{NA}.
#' @return copy of 'mat_' with 'poly' or a new matrix with 'poly'.
#' @keywords internal
NULL

#' @title Contours Filling
#' @name cpp_fill
#' @description
#' This function is designed to fill contours.
#' @param ctl a List, containing contour tracing labeling, object of class `IFCip_ctl`
#' @param label a Nullable IntegerVector corresponding to the label(s) of desired set of contour to be filled.
#' Default is \code{0} to fill all sets of contours found.
#' @param i_border a bool, to whether or not draw inside contours if some were identified. Default is \code{true}.
#' @param i_fill a bool, to whether or not fill inside contours if some were identified. Default is \code{true}.
#' @param i_neg_border a bool, to whether or not inside border, if drawn, should be negated. Default is \code{false}.
#' @param o_border a bool, to whether or not draw external contours. Default is \code{true}.
#' @param o_fill a bool, to whether or not fill external contours. Default is \code{true}.
#' @param o_neg_border a bool, to whether or not external border, if drawn, should be negated. Default is \code{false}.
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Contours Filling Outer Only
#' @name cpp_fill_out
#' @description
#' This function is designed to fill the most external contours.
#' @param ctl a List, containing contour tracing labeling, object of class `IFCip_ctl`.
#' @param label a Nullable IntegerVector corresponding to the label(s) of desired set of contour to be filled.
#' Default is \code{0} to fill all sets of contours found.
#' @param o_border a bool, to whether or not draw external contours. Default is \code{true}.
#' @param o_fill a bool, to whether or not fill external contours. Default is \code{true}.
#' @param o_neg_border a bool, to whether or not external border, if drawn, should be negated. Default is \code{false}.
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Connected Region Flood Filling
#' @name cpp_floodfill
#' @description
#' Flood fills image region.
#' @param img, a NumericMatrix. The image to be modified.
#' @param markers, a NumericMatrix, It should be a matrix with at least 3 columns being "row", "col", and "value", respectively. It represents coordinates of the seeds to start filling 'img', with the new "value". Eventually, an additional column being "tolerance" can be provided.\cr
#' /!\ Note that "row" and "col" should be provided at C-level meaning 1st start at 0.
#' @return a NumericMatrix, the modified image.
#' @keywords internal
NULL

#' @title Matrix Threshold
#' @name cpp_threshold
#' @description
#' This function takes a image and checks for members superior or equal
#' to max(img) - k * diff(range(img)) / 100 within msk
#' @param img a NumericMatrix
#' @param msk a NumericMatrix
#' @param k constant to be checked. Default is 0.
#' @param removal uint8_t, object removal method. Default is 0 for no removal. Otherwise, if\cr
#' -1, for clipped removal, keep non clipped foreground.\cr
#' -2, height clipped removal.\cr
#' -3, width clipped removal.\cr
#' -4, only keep background:.\cr
#' -5, only keep foreground.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Implementation of Zheng-Suen Thinning
#' @name cpp_thinning_zs
#' @description
#' This function is designed to identify mask skeleton.
#' @param mat a LogicalMatrix, containing mask.
#' @details adaptation of 'A fast parallel algorithm for thinning digital patterns' from T. Y. Zhang, C. Y. Suen.
#' Communications of the ACM, March 1984 \doi{10.1145/357994.358023}.
#' @return a LogicalMatrix with the mask thinned.
#' @keywords internal
NULL

#' @title Implementation of Ben Boudaoud-Sider-Tari Thinning
#' @name cpp_thinning_bst
#' @description
#' This function is designed to identify mask skeleton.
#' @param mat a LogicalMatrix, containing mask.
#' @details adaptation of 'A new thinning algorithm for binary images' from L. Ben Boudaoud, A. Sider, A. Tari.
#' 3rd international conference on control, engineering & information technology, May 2015. \doi{10.1109/CEIT.2015.7233099}.
#' @return a LogicalMatrix with the mask thinned.
#' @keywords internal
NULL

#' @title Images Similarity Measurement
#' @name cpp_similarity
#' @description
#' This function is designed to score similarity between two images.
#' @param img1 a NumericMatrix, containing image values.
#' @param img2 a NumericMatrix, containing image values.
#' @param msk a LogicalMatrix, containing mask.
#' @details the similarity is the log transformed Pearson's Correlation Coefficient.
#' It is a measure of the degree to which two images are linearly correlated within a masked region.\cr
#' See "Quantitative measurement of nuclear translocation events using similarity analysis of multispectral cellular images obtained in flow"
#' by T.C. George et al. Journal of Immunological Methods Volume 311, Issues 1–2, 20 April 2006, Pages 117-129 \doi{doi.org/10.1016/j.jim.2006.01.018}
#' @return a double, the similarity.
#' @keywords internal
NULL

#' @title Images Bright Detail Similarity Measurement
#' @name cpp_bright_similarity
#' @description
#' This function is designed to score similarity between two bright detail images.
#' @param img1 a NumericMatrix, containing bright detail image values.
#' @param img2 a NumericMatrix, containing bright detail image values.
#' @param msk a LogicalMatrix, containing mask.
#' @details the bright detail similarity is the non-mean normalized version of the log transformed Pearson's Correlation Coefficient.
#' It is designed to compare the small bright image detail of two images within a masked region.\cr
#' See "Quantitative analysis of protein co-localization on B cells opsonized with rituximab and complement using the ImageStream multispectral imaging flow cytometer"
#' by P.V. Beum et al. Journal of Immunological Methods Volume 317, Issues 1–2, 20 December 2006, Pages 90-99 \doi{doi.org/10.1016/j.jim.2006.09.012}
#' @return a double, the similarity.
#' @keywords internal
NULL

#' @title Create Gaussian Kernel
#' @name cpp_make_gaussian
#' @description
#' This function is designed to create a gaussian kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @param sigma, a double, deviation of the filter used. Default is \code{-0.3}. If negative, \code{'sigma'} will be determined using \code{-1.0 * sigma * ((size - 1) * 0.5)}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Create Laplacian Kernel
#' @name cpp_make_laplacian
#' @description
#' This function is designed to create a laplacian kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @param sigma, a double, deviation of the filter used. Default is \code{-0.3}. If negative, \code{'sigma'} will be determined using \code{-1.0 * sigma * ((size - 1) * 0.5)}.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Create a Disc
#' @name cpp_make_disc
#' @description
#' This function is designed to create a disc kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Box
#' @name cpp_make_box
#' @description
#' This function is designed to create a box kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Plus
#' @name cpp_make_plus
#' @description
#' This function is designed to create a plus kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Cross
#' @name cpp_make_cross
#' @description
#' This function is designed to create a cross kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Diamond
#' @name cpp_make_diamond
#' @description
#' This function is designed to create a diamond kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Convex Hull
#' @name cpp_convexhull
#' @description
#' Computes 2D convex hull of a set of points.
#' @param pts a 2-column matrix defining the locations (x and y coordinates, respectively) of points.
#' x has to be in column 0 and y in column 1 (C index, add 1 for R).
#' @return a vector of row indices of 'pts' that constitutes convex hull vertices.
#' @source Adaptation of Andrew's Monotone Chain Algorithm A. M. Andrew, 'Another Efficient Algorithm
#' for Convex Hulls in Two Dimension', Information Processing Letters, 9, 1979, pp216-219 reported
#' in M. A. Jayaram, Hasan Fleyeh, 'Convex Hulls in Image Processing: A Scoping Review', 
#' American Journal of Intelligent Systems, Vol. 6 No. 2, 2016, pp. 48-58.
#' @keywords internal
NULL

cpp_background <- function(img, margin = 4L, extra = 0L, is_cif = FALSE) {
    .Call(`_IFCip_cpp_background`, img, margin, extra, is_cif)
}

cpp_antipodalpairs <- function(pts) {
    .Call(`_IFCip_cpp_antipodalpairs`, pts)
}

cpp_bbox <- function(pts, scale = 1.0) {
    .Call(`_IFCip_cpp_bbox`, pts, scale)
}

cpp_rescale <- function(img, msk_ = NULL, value = NA_real_, n_lev = 256L, invert = FALSE, bin = FALSE) {
    .Call(`_IFCip_cpp_rescale`, img, msk_, value, n_lev, invert, bin)
}

cpp_scalerev <- function(img, sca_ = NULL) {
    .Call(`_IFCip_cpp_scalerev`, img, sca_)
}

cpp_cooc <- function(img, delta) {
    .Call(`_IFCip_cpp_cooc`, img, delta)
}

cpp_h_features <- function(cooc, invariant = FALSE) {
    .Call(`_IFCip_cpp_h_features`, cooc, invariant)
}

cpp_centroid <- function(img) {
    .Call(`_IFCip_cpp_centroid`, img)
}

cpp_rmoment <- function(img, p = 0L, q = 0L) {
    .Call(`_IFCip_cpp_rmoment`, img, p, q)
}

cpp_cmoment <- function(img, cx = 0.0, cy = 0.0, p = 0L, q = 0L) {
    .Call(`_IFCip_cpp_cmoment`, img, cx, cy, p, q)
}

cpp_features_hu1 <- function(img, mag = 1.0) {
    .Call(`_IFCip_cpp_features_hu1`, img, mag)
}

cpp_features_hu2 <- function(img, mag = 1.0) {
    .Call(`_IFCip_cpp_features_hu2`, img, mag)
}

cpp_basic <- function(img, msk, mag = 1.0) {
    .Call(`_IFCip_cpp_basic`, img, msk, mag)
}

cpp_features_hu3 <- function(img, msk, components = 0L, mag = 1.0) {
    .Call(`_IFCip_cpp_features_hu3`, img, msk, components, mag)
}

cpp_multi_otsu <- function(img, msk_ = NULL, n_comp = 2L, n_lev = 256L) {
    .Call(`_IFCip_cpp_multi_otsu`, img, msk_, n_comp, n_lev)
}

cpp_distance_eucl <- function(msk) {
    .Call(`_IFCip_cpp_distance_eucl`, msk)
}

cpp_distance_eucl_norm <- function(msk) {
    .Call(`_IFCip_cpp_distance_eucl_norm`, msk)
}

cpp_distance_manh <- function(msk) {
    .Call(`_IFCip_cpp_distance_manh`, msk)
}

cpp_distance_manh_norm <- function(msk) {
    .Call(`_IFCip_cpp_distance_manh_norm`, msk)
}

cpp_disttrans_manh <- function(img) {
    .Call(`_IFCip_cpp_disttrans_manh`, img)
}

cpp_disttrans_eucl <- function(img) {
    .Call(`_IFCip_cpp_disttrans_eucl`, img)
}

cpp_voronoi_eucl <- function(img) {
    .Call(`_IFCip_cpp_voronoi_eucl`, img)
}

cpp_voronoi_manh <- function(img) {
    .Call(`_IFCip_cpp_voronoi_manh`, img)
}

cpp_zernike1 <- function(img, msk_ = NULL, cx = 0.0, cy = 0.0, zmax = 15L, radius = 15.0) {
    .Call(`_IFCip_cpp_zernike1`, img, msk_, cx, cy, zmax, radius)
}

cpp_zernike2 <- function(img, msk_ = NULL, cx = 0.0, cy = 0.0, zmax = 15L, radius = 15.0) {
    .Call(`_IFCip_cpp_zernike2`, img, msk_, cx, cy, zmax, radius)
}

cpp_AND_M <- function(list) {
    .Call(`_IFCip_cpp_AND_M`, list)
}

cpp_OR_M <- function(list) {
    .Call(`_IFCip_cpp_OR_M`, list)
}

cpp_NEG_M <- function(mat) {
    .Call(`_IFCip_cpp_NEG_M`, mat)
}

cpp_k_equal_M <- function(mat, k = 3.0) {
    .Call(`_IFCip_cpp_k_equal_M`, mat, k)
}

cpp_k_sup_equal_M <- function(mat, k = 3.0) {
    .Call(`_IFCip_cpp_k_sup_equal_M`, mat, k)
}

cpp_k_inf_equal_M <- function(mat, k = 3.0) {
    .Call(`_IFCip_cpp_k_inf_equal_M`, mat, k)
}

cpp_shift <- function(mat, d_row = 0L, d_col = 0L, add_noise = TRUE, bg = 0.0, sd = 0.0) {
    .Call(`_IFCip_cpp_shift`, mat, d_row, d_col, add_noise, bg, sd)
}

cpp_flip <- function(mat, which = TRUE) {
    .Call(`_IFCip_cpp_flip`, mat, which)
}

cpp_padding <- function(mat, extra_rows = 0L, extra_cols = 0L, method = 1L, k = 0.0) {
    .Call(`_IFCip_cpp_padding`, mat, extra_rows, extra_cols, method, k)
}

cpp_filter <- function(mat, kernel, method = 5L, k = NA_real_, what = "") {
    .Call(`_IFCip_cpp_filter`, mat, kernel, method, k, what)
}

cpp_sd <- function(mat, kernel, method = 5L, k = NA_real_) {
    .Call(`_IFCip_cpp_sd`, mat, kernel, method, k)
}

cpp_mean <- function(mat, kernel, method = 5L, k = NA_real_) {
    .Call(`_IFCip_cpp_mean`, mat, kernel, method, k)
}

cpp_median <- function(mat, kernel, method = 5L, k = NA_real_) {
    .Call(`_IFCip_cpp_median`, mat, kernel, method, k)
}

cpp_mode <- function(mat, kernel, method = 5L, k = NA_real_) {
    .Call(`_IFCip_cpp_mode`, mat, kernel, method, k)
}

cpp_mid <- function(mat, kernel, method = 5L, k = NA_real_) {
    .Call(`_IFCip_cpp_mid`, mat, kernel, method, k)
}

cpp_convolve2d <- function(mat, kernel, method = 5L, k = 0.0) {
    .Call(`_IFCip_cpp_convolve2d`, mat, kernel, method, k)
}

cpp_correlate2d <- function(mat, kernel, method = 5L, k = 0.0) {
    .Call(`_IFCip_cpp_correlate2d`, mat, kernel, method, k)
}

cpp_uw <- function(mat, kernel, erode = TRUE) {
    .Call(`_IFCip_cpp_uw`, mat, kernel, erode)
}

cpp_erode <- function(mat, kernel) {
    .Call(`_IFCip_cpp_erode`, mat, kernel)
}

cpp_dilate <- function(mat, kernel) {
    .Call(`_IFCip_cpp_dilate`, mat, kernel)
}

cpp_opening <- function(mat, kernel) {
    .Call(`_IFCip_cpp_opening`, mat, kernel)
}

cpp_closing <- function(mat, kernel) {
    .Call(`_IFCip_cpp_closing`, mat, kernel)
}

cpp_gradient <- function(mat, kernel) {
    .Call(`_IFCip_cpp_gradient`, mat, kernel)
}

cpp_tophat_white <- function(mat, kernel) {
    .Call(`_IFCip_cpp_tophat_white`, mat, kernel)
}

cpp_tophat_black <- function(mat, kernel) {
    .Call(`_IFCip_cpp_tophat_black`, mat, kernel)
}

cpp_tophat_self <- function(mat, kernel) {
    .Call(`_IFCip_cpp_tophat_self`, mat, kernel)
}

cpp_cont <- function(mat, kernel) {
    .Call(`_IFCip_cpp_cont`, mat, kernel)
}

cpp_laplacian <- function(mat, kernel) {
    .Call(`_IFCip_cpp_laplacian`, mat, kernel)
}

cpp_erode_old <- function(mat, kernel, iter = 0L, msk_ = NULL) {
    .Call(`_IFCip_cpp_erode_old`, mat, kernel, iter, msk_)
}

cpp_dilate_old <- function(mat, kernel, iter = 0L, msk_ = NULL) {
    .Call(`_IFCip_cpp_dilate_old`, mat, kernel, iter, msk_)
}

cpp_rec_dilate <- function(markers, img, kernel = NULL) {
    .Call(`_IFCip_cpp_rec_dilate`, markers, img, kernel)
}

cpp_rec_erode <- function(markers, img, kernel = NULL) {
    .Call(`_IFCip_cpp_rec_erode`, markers, img, kernel)
}

cpp_HMIN <- function(img, h = NA_real_, h_lev = 1L, n_lev = 65536L, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_HMIN`, img, h, h_lev, n_lev, kernel, msk_)
}

cpp_HMAX <- function(img, h = NA_real_, h_lev = 1L, n_lev = 65536L, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_HMAX`, img, h, h_lev, n_lev, kernel, msk_)
}

cpp_RMIN <- function(img, n_lev = 65536L, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_RMIN`, img, n_lev, kernel, msk_)
}

cpp_RMAX <- function(img, n_lev = 65536L, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_RMAX`, img, n_lev, kernel, msk_)
}

cpp_EMAX <- function(img, h = NA_real_, h_lev = 1L, n_lev = 65536L, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_EMAX`, img, h, h_lev, n_lev, kernel, msk_)
}

cpp_EMIN <- function(img, h = NA_real_, h_lev = 1L, n_lev = 65536L, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_EMIN`, img, h, h_lev, n_lev, kernel, msk_)
}

cpp_geo_tophat_white <- function(img, kernel = NULL) {
    .Call(`_IFCip_cpp_geo_tophat_white`, img, kernel)
}

cpp_geo_tophat_black <- function(img, kernel = NULL) {
    .Call(`_IFCip_cpp_geo_tophat_black`, img, kernel)
}

cpp_watershed_sv1 <- function(mat, n_lev = 256L, draw_lines = TRUE, invert = FALSE, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_watershed_sv1`, mat, n_lev, draw_lines, invert, kernel, msk_)
}

cpp_watershed_sv2 <- function(mat, n_lev = 256L, draw_lines = TRUE, invert = FALSE, kernel = NULL, msk_ = NULL) {
    .Call(`_IFCip_cpp_watershed_sv2`, mat, n_lev, draw_lines, invert, kernel, msk_)
}

cpp_ctl <- function(mat, global = FALSE) {
    .Call(`_IFCip_cpp_ctl`, mat, global)
}

cpp_dilate_ctl <- function(ctl, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_dilate_ctl`, ctl, kernel, iter)
}

cpp_erode_ctl <- function(ctl, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_erode_ctl`, ctl, kernel, iter)
}

cpp_polydraw <- function(poly, border = 1.0, fill = 1.0, tol = 0.0, edge = FALSE, mat_ = NULL) {
    .Call(`_IFCip_cpp_polydraw`, poly, border, fill, tol, edge, mat_)
}

cpp_fill <- function(ctl, label = as.integer( c(0)), i_border = TRUE, i_fill = TRUE, i_neg_border = FALSE, o_border = TRUE, o_fill = TRUE, o_neg_border = FALSE) {
    .Call(`_IFCip_cpp_fill`, ctl, label, i_border, i_fill, i_neg_border, o_border, o_fill, o_neg_border)
}

cpp_fill_out <- function(ctl, label = as.integer( c(0)), o_border = TRUE, o_fill = TRUE, o_neg_border = FALSE) {
    .Call(`_IFCip_cpp_fill_out`, ctl, label, o_border, o_fill, o_neg_border)
}

cpp_floodfill <- function(img, markers) {
    .Call(`_IFCip_cpp_floodfill`, img, markers)
}

cpp_threshold <- function(img, msk, k = 0.0, removal = 0L) {
    .Call(`_IFCip_cpp_threshold`, img, msk, k, removal)
}

cpp_thinning_zs <- function(mat) {
    .Call(`_IFCip_cpp_thinning_zs`, mat)
}

cpp_thinning_bst <- function(mat) {
    .Call(`_IFCip_cpp_thinning_bst`, mat)
}

cpp_similarity <- function(img1, img2, msk) {
    .Call(`_IFCip_cpp_similarity`, img1, img2, msk)
}

cpp_bright_similarity <- function(img1, img2, msk) {
    .Call(`_IFCip_cpp_bright_similarity`, img1, img2, msk)
}

cpp_make_gaussian <- function(size = 3L, sigma = -0.3) {
    .Call(`_IFCip_cpp_make_gaussian`, size, sigma)
}

cpp_make_laplacian <- function(size = 3L, sigma = -0.3) {
    .Call(`_IFCip_cpp_make_laplacian`, size, sigma)
}

cpp_make_disc <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_disc`, size)
}

cpp_make_box <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_box`, size)
}

cpp_make_plus <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_plus`, size)
}

cpp_make_cross <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_cross`, size)
}

cpp_make_diamond <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_diamond`, size)
}

cpp_convexhull <- function(pts) {
    .Call(`_IFCip_cpp_convexhull`, pts)
}

