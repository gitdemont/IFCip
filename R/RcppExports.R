# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Image Background
#' @name cpp_background
#' @description
#' This function is designed to compute image background on a "raw" image
#' @param img a NumericMatrix, containing image intensity values.
#' @param margin R_len_t number of rows margin used to compute background. Default is 4.
#' @param extra R_len_t number of extra columns used to compute background. Default is 0.
#' @param is_cif a bool whether 'ímg' originates from a cif_file or not. Default is false.
#' @return a NumericVector of background mean and sd
#' @keywords internal
NULL

#' @title Antipodal Pairs of Convex Hull
#' @name cpp_antipodalpairs
#' @description
#' Computes antipodal pairs of a convex polygon 
#' @param pts a 2-column matrix defining the locations (x and y coordinates, respectively) of points.
#' It has to be an object of class `IFCip_convexhull`
#' @source Adaptation from \url{https://escholarship.mcgill.ca/concern/theses/fx719p46g} in Computational geometry with the rotating calipers authored by Pirzadeh, Hormoz under supervision of Toussaint, Godfried T. at McGill University.
#' @return an IntegerVector of antipodal pairs of the convex input polygon. Note that this vector of indices is in C sort 1st start at 0; add 1 to use it in R.
#' @keywords internal
NULL

#' @title Right Shift Matrix
#' @name cpp_R_shift_M
#' @description
#' This function is designed to right shift bits of a matrix to [0, 2^bits - 1]
#' @param mat a Rcpp::IntegerMatrix, containing image intensity values.
#' @param bits uint8_t number of bit to shift matrix values. Default is 4. Allowed are [2,10].
#' If shifted value does not respect [0, 2^bits - 1] an error is thrown.
#' @return an Rcpp::IntegerMatrix.
#' @keywords internal
NULL

#' @title hpp_rescale_M
#' @name cpp_rescale_M
#' @description
#' This function is designed to rescale a matrix to [0, 2^bits - 1]
#' @param mat a Rcpp::NumericMatrix, containing image intensity values.
#' @param bits uint8_t number of bit to shift matrix values. Default is 4. Allowed are [2,10].
#' Rescaled values will normalized to [0, 2^bits - 1]
#' @return an Rcpp::IntegerMatrix.
#' @keywords internal
NULL

#' @title Haralick Co-Occurrence Matrix
#' @name cpp_cooc
#' @description
#' This function is designed to compute Haralick co-occurrence matrix
#' @param img a Rcpp::IntegerMatrix of class `IFCip_rescale`, containing image intensity values.
#' @param msk a LogicalMatrix, containing mask.
#' @param delta uint8_t offset from which co-oocurence has to be computed to. Default is 1.
#' @details See 'Textural Features for Image Classification', Haralick et. al (1979),
#' available at: \url{https://haralick.org/journals/TexturalFeatures.pdf}
#' @return a list whose members are normalized Gray-Level Co-occurrence Matrices at angles 0, 45, 90 and 315.
#' @keywords internal
NULL

#' @title Haralick Features
#' @name cpp_h_features
#' @description
#' This function is designed to compute Haralick's features
#' @param cooc a Rcpp::NumericMatrix of class `IFCip_cooc`, normalized co-occurrence matrix to compute Haralick's features from.
#' @param invariant a bool, whether to compute invariant Haralick's texture features. Default is false.
#' Not yet supported.
#' @details Haralick's invariant texture features are described in Löfstedt T, Brynolfsson P, Asklund T, Nyholm T, Garpebring A (2019) Gray-level invariant Haralick texture features.
#' PLoS ONE 14(2): e0212110. \url{https://doi.org/10.1371/journal.pone.0212110}
#' @return a Rcpp::NumericVector of Haralick's texture features
#' @keywords internal
NULL

#' @title Hu's Centroid
#' @name cpp_centroid
#' @description
#' This function is designed to compute Hu's image centroids.
#' @param img a NumericMatrix, containing image intensity values.
#' @keywords internal
NULL

#' @title Hu's Raw Moment
#' @name cpp_rmoment
#' @description
#' This function is designed to compute Hu's image raw moment.
#' @param img a NumericMatrix, containing image intensity values.
#' @param p uint8_t: p order. Default is 0.
#' @param q uint8_t: q order. Default is 0.
#' @keywords internal
NULL

#' @title Hu's Central Moment
#' @name cpp_cmoment
#' @description
#' This function is designed to compute Hu's image central moment.
#' @param img a NumericMatrix, containing image intensity values.
#' @param cx double, x centroid of the img\cr
#' @param cy double, y centroid of the img\cr
#' @param p uint8_t: p order. Default is 0.
#' @param q uint8_t: q order. Default is 0.
#' @keywords internal
NULL

#' @title Hu's Partial Features
#' @name cpp_features_hu1
#' @description
#' This function is designed to compute Hu's central moments.
#' @param img a NumericMatrix, containing image intensity values.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -5.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericVector of Hu's moments values.\cr
#' -Area: img's area\cr
#' -circularity: img's circularity\cr
#' -Minor Axis: img's ellipsis minor axis\cr
#' -Major Axis: img's ellipsis major axis\cr
#' -Aspect Ratio: img's ratio of minor axis over major axis\cr
#' -Angle: img's ellipsis angle with x axis (in radians)\cr
#' -theta: img's ellipsis theta angle (in radians)\cr
#' -Eccentricity: img's ellipsis ecentricity\cr
#' -pix cx: img's pixel x centroïd\cr
#' -pix cy: img's pixel y centroïd\cr
#' -pix min axis: img's ellipsis minor axis in pixels\cr
#' -pix_maj_axis: img's ellipsis major axis in pixels\cr
#' -pix count: img's area in pixels.
#' @keywords internal
NULL

#' @title Hu's Full Features
#' @name cpp_features_hu2
#' @description
#' This function is designed to compute Hu's central moments + 7 invariant moments
#' @param img a NumericMatrix, containing image intensity values.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -5.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericVector of Hu's moments values.\cr
#' -Area: img's area\cr
#' -circularity: img's circularity\cr
#' -Minor Axis: img's ellipsis minor axis\cr
#' -Major Axis: img's ellipsis major axis\cr
#' -Aspect Ratio: img's ratio of minor axis over major axis\cr
#' -Angle: img's ellipsis angle with x axis (in radians)\cr
#' -theta: img's ellipsis theta angle (in radians)\cr
#' -Eccentricity: img's ellipsis ecentricity\cr
#' -pix cx: img's pixel x centroïd\cr
#' -pix cy: img's pixel y centroïd\cr
#' -pix min axis: img's ellipsis minor axis in pixels\cr
#' -pix_maj_axis: img's ellipsis major axis in pixels\cr
#' -pix count: img's area in pixels\cr
#' -inv[1-7]: image invariant moments.
#' @keywords internal
NULL

#' @title Basic Features
#' @name cpp_basic
#' @description
#' This function is designed to compute very basic features based on Hu's moments + intensities.
#' @param img a NumericMatrix, containing image intensity values.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -5.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericVector of basic features values.\cr
#' -Area: msk's area\cr
#' -circularity: msk's circularity\cr
#' -Minor Axis: msk's ellipsis minor axis\cr
#' -Major Axis: msk's ellipsis major axis\cr
#' -Aspect Ratio: msk's ratio of minor_axis over major_axis\cr
#' -Angle: msk's ellipsis angle with x axis (in radians)\cr
#' -theta: msk's ellipsis theta angle (in radians)\cr
#' -eccentricity: msk's ellipsis ecentricity\cr
#' -pix cx: msk's pixel x centroïd\cr
#' -pix cy: msk's pixel y centroïd\cr
#' -pix min_axis: msk's ellipsis minor axis in pixels\cr
#' -pix maj axis: msk's ellipsis major axis in pixels\cr
#' -pix count: msk's area in pixels\cr
#' -Raw Mean Pixel: img's mean pixel intensity\cr
#' -Raw Min Pixel: img's minimal pixel intensity\cr
#' -Raw Max Pixel: img's maximal pixel intensity.
#' @keywords internal
NULL

#' @title Image Features Extraction
#' @name cpp_features_hu3
#' @description
#' This function is designed to compute image features.
#' @param img a NumericMatrix, containing image intensity values.
#' @param msk an IntegerMatrix, containing msk components.
#' @param components an unsigned integer. Maximal component component number to retrieve features about.
#' Default is 0 to retrieve  features for all components.
#' @param mag a double, magnification scale. Default is 1.0. Use:\cr
#' -1.0 for 20x\cr
#' -5.0 for 40x\cr
#' -9.0 for 60x.
#' @return a NumericMatrix whose rows are component numbers and columns are:\cr
#' -Area, area of the component\cr
#' -circularity, circularity of the component\cr
#' -Minor Axis, minor axis of the component\cr
#' -Major Axis, major axis of the component\cr
#' -Aspect Ratio, aspect ratio of the component\cr
#' -Angle, angle of the component\cr
#' -theta, theta of the component\cr
#' -eccentricity, eccentricity of the component\cr
#' -Minor Axis Intensity, intensity weighted minor axis of the component\cr
#' -Major Axis Intensity, intensity weighted major axis of the component\cr
#' -Aspect Ratio Intensity, intensity weighted aspect ratio of the component\cr
#' -Angle Intensity, intensity weighted angle of the component\cr
#' -theta intensity, intensity weighted theta of the component\cr
#' -eccentricity intensity, intensity weighted eccentricity of the component\cr
#' -pix cx, x centroid of the component in pixels\cr
#' -pix cy, y centroid of the component in pixels\cr
#' -pix min axis, minor axis of the component in pixels\cr
#' -pix maj axis, major axis of the component in pixels\cr
#' -pix count, number of pixels occupied by the component\cr
#' -inv[1-8], component Hu's invariant moments\cr
#' -Raw Mean Pixel, mean pixels intensity of the component\cr
#' -Raw Min Pixel, pixels intensity minimum of the component\cr
#' -Raw Max Pixel, pixels intensity maximum of the component\cr
#' -Std Dev, pixels intensity standard variation of the component\cr
#' -skewness, component's skewness\cr
#' -kurtosis, component's kurosis.  
#' @keywords internal
NULL

#' @title Mask Euclidean Distance
#' @name cpp_distance_eucl
#' @description
#' This function is designed to compute Euclidean distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return an NumericMatrix.
#' @keywords internal
NULL

#' @title Mask Normalized Euclidean Distance
#' @name cpp_distance_eucl_norm
#' @description
#' This function is designed to compute normalized Euclidean distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Mask Manhattan Distance
#' @name cpp_distance_manh
#' @description
#' This function is designed to compute Manhattan distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Mask Normalized Manhattan Distance
#' @name cpp_distance_manh_norm
#' @description
#' This function is designed to compute normalized Manhattan distance from background to centroïds' foreground
#' @param msk an IntegerMatrix, containing connected components.
#' @return an NumericMatrix.
#' @keywords internal
NULL

#' @title Manhattan Distance Transform
#' @name cpp_disttrans_manh
#' @description
#' This function computes the Manhattan distance transform of an image by implementing A. Meijster algorithm.
#' @param img, a NumericMatrix.
#' @details adaptation of 'A General Algorithm For Computing Distance Transforms In Linear Time' from W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink.
#' Mathematical Morphology and its Applications to Image and Signal Processing. February 2002, Pages 331-340.\url{https://doi.org/10.1007/0-306-47025-X_36}\cr
#' Values > 0 will be considered as foreground whereas all other values will be concidered as background (i.e. 0).
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Euclidean Distance Transform
#' @name cpp_disttrans_eucl
#' @description
#' This function computes the Euclidean distance transform of an image by implementing A. Meijster algorithm.
#' @param img, a NumericMatrix.
#' @details adaptation of 'A General Algorithm For Computing Distance Transforms In Linear Time' from W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink.
#' Mathematical Morphology and its Applications to Image and Signal Processing. February 2002, Pages 331-340.\url{https://doi.org/10.1007/0-306-47025-X_36}\cr
#' Values > 0 will be considered as foreground whereas all other values will be concidered as background (i.e. 0).
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Euclidean Voronoï
#' @name cpp_voronoi_eucl
#' @description
#' This function computes Voronoï diagram using Euclidean distance of a seed image.
#' @param img, a positive IntegerMatrix where values > 0 represent foreground seeds.
#' @details img will be passed to connected component labelling and centroïd of each identified components will be used to build Voronoï diagram.
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Manhattan Voronoï
#' @name cpp_voronoi_manh
#' @description
#' This function computes Voronoï diagram using Manhattan distance of a seed image.
#' @param img, a positive IntegerMatrix where values > 0 represent foreground seeds.
#' @details img will be passed to connected component labelling and centroïd of each identified components will be used to build Voronoï diagram.
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Watershed Transformation
#' @name cpp_watershed
#' @description
#' This function computes the watershed transformation of an image.
#' @param mat, a NumericMatrix; a distance transform matrix is expected.
#' @param connectivity, an unsigned short either 4 or 8 describing pixel neighborhood. Default is 8.
#' @param levels, an unsigned short determining the number elevation levels. Default is 256, should be at least 2.
#' @detais adaptation of 'Watersheds in digital spaces: an efficient algorithm based on immersion simulations' from  L. Vincent and P. Soille.
#' In IEEE Transactions on Pattern Analysis and Machine Intelligence, 13(6):583-598, June 1991.\cr
#' The algorithm is reviewed in 'The Watershed Transform: Definitions, Algorithms and Parallelization Strategies'
#' from Roerdink, J. B. T. M., & Meijster, A. (2000) in Fundamenta Informaticae, 41, 187-228 \url{https://doi.org/10.3233/FI-2000-411207}
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Zernike's Features
#' @name cpp_zernike1
#' @description
#' This function is designed to compute Zernike's moments from image.
#' It will compute Zernike's moments but will not return image projection.
#' @param img a NumericMatrix, containing image intensity values.
#' @param cx a double. X centroid.
#' @param cy a double. Y centroid.
#' @param nmax a uint8_t, maximal order of Zernike polynomials to be computed. Default is 15. Values outside [0,99] will be clipped.
#' Be aware that computation of Zernike's moments can be quite long when 'nmax' is high.
#' @param radius a numeric, radius of the circle in pixels around object centers from which the features are calculated. Default is 15.
#' @source Adaptation from \url{https://github.com/aoles/EBImage} in v3.12.0, authored by Andrzej Oles, Gregoire Pau, Mike Smith, Oleg Sklyar, Wolfgang Huber, with contributions from Joseph Barry and Philip A. Marais \email{andrzej.oles@embl.de}.
#' @keywords internal
NULL

#' @title Zernike's Features with Projections
#' @name cpp_zernike2
#' @description
#' This function is designed to compute Zernike's moments from image.
#' It will compute Zernike's moments but also return image projection.
#' @param img a NumericMatrix, containing image intensity values.
#' @param cx a double. X centroid.
#' @param cy a double. Y centroid.
#' @param nmax a uint8_t, maximal order of Zernike polynomials to be computed. Default is 15. Values outside [0,99] will be clipped.
#' Be aware that computation of Zernike's moments can be quite long when 'nmax' is high.
#' @param radius a numeric, radius of the circle in pixels around object centers from which the features are calculated. Default is 15.
#' @source Adaptation from \url{https://github.com/aoles/EBImage} in v3.12.0, authored by Andrzej Oles, Gregoire Pau, Mike Smith, Oleg Sklyar, Wolfgang Huber, with contributions from Joseph Barry and Philip A. Marais \email{andrzej.oles@embl.de}.
#' @keywords internal
NULL

#' @title Matrix List AND Logic
#' @name cpp_AND_M
#' @description
#' This function takes a list of matrices and returns the AND operation applied on these matrices.
#' @param list a list of logical matrices.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix List OR Logic
#' @name cpp_OR_M
#' @description
#' This function takes a list of matrices and returns the OR operation applied on these matrices.
#' @param list a list of logical matrices.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Neg Logic
#' @name cpp_NEG_M
#' @description
#' This function takes a logical matrix and returns its negation.
#' @param mat LogicalMatrix.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Logic Equal
#' @name cpp_k_equal_M
#' @description
#' This function takes an NumericMatrix and checks for members equal to k
#' @param mat a NumericMatrix
#' @param k constant to be checked. Default is 3.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Logic Superior and Equal
#' @name cpp_k_sup_equal_M
#' @description
#' This function takes an NumericMatrix and checks for members superior or equal to k
#' @param mat a NumericMatrix
#' @param k constant to be checked. Default is 3.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Matrix Logic Inferior and Equal
#' @name cpp_k_inf_equal_M
#' @description
#' This function takes an NumericMatrix and checks for members inferior or equal to k
#' @param mat a NumericMatrix
#' @param k constant to be checked. Default is 3.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Image Shift
#' @name cpp_shift
#' @description
#' Function that shifts mat according to d_row and d_col parameters
#' @param mat a numeric matrix.
#' @param d_row an integer, giving row shift. Default is 0 for no change.
#' @param d_col an integer, giving col shift. Default is 0 for no change.
#' @param add_noise logical, if true adds normal noise when at least one new dimension is larger than original mat dimensions
#' Rcpp::rnorm() function is used. Default is true.
#' @param bg double, mean value of the background added if add_noise is true. Default is 0.
#' @param sd double, standard deviation of the background added if add_noise is true. Default is 0.
#' @return a shifted matrix with additional rows/columns if d_row or d_col are different from 0.
#' @keywords internal
NULL

#' @title Image Flip
#' @name cpp_flip
#' @description
#' Function that flips mat 
#' @param mat NumericMatrix.
#' @param which bool. Default is true. Use true to flip horizontally and false vertically.
#' @return a flipped matrix.
#' @keywords internal
NULL

#' @title Image Padding
#' @name cpp_padding
#' @description
#' This function creates a new matrix with extra rows / cols according to input mat, kernel
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param method, a uint8_t. Default is 1, allowed are [1-8].\cr
#' -1, extra cols / rows will be filled with 'k', returned 'out' will not be filled.\cr
#' -2, extra cols / rows will be filled with the closest col / row, returned 'out' will not be filled.\cr
#' -3, extra cols / rows will be filled mirroring neighbor cols / rows, returned 'out' will not be filled.\cr
#' -4, extra cols / rows will be filled repeating neighbor cols / rows, returned 'out' will not be filled.\cr
#' -5, extra cols / rows will be filled with 'k', returned 'out' will be filled with mat.\cr
#' -6, extra cols / rows will be filled with the closest col / row, returned 'out' will be filled with mat.\cr
#' -7, extra cols / rows will be filled mirroring neighbor cols / rows, returned 'out' will be filled with mat.\cr
#' -8, extra cols / rows will be filled repeating neighbor cols / rows, returned 'out' will be filled with mat.
#' @param k, a double, constant used when method is 1 or 4. Default is 0.0.
#' @return a List whose elements are:\cr
#' -out, a NumericMatrix, with extra cols / rows\cr
#' -ori_c, a R_len_t with x coordinate of the 1st non extra element,\cr
#' -ori_r, a R_len_t with y coordinate of the 1st non extra element.
#' @keywords internal
NULL

#' @title Image Standard Deviation Filtering
#' @name cpp_sd
#' @description
#' This function applies standard deviation filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Median Filtering
#' @name cpp_median
#' @description
#' This function applies median filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Mode Filtering
#' @name cpp_mode
#' @description
#' This function applies mode filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Mid Filtering
#' @name cpp_mid
#' @description
#' This function applies mid filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Filtering by Convolution
#' @name cpp_convolve2d
#' @description
#' This function applies 2D convolution filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Filtering by Correlation
#' @name cpp_correlate2d
#' @description
#' This function applies 2D correlation filtering on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Erosion
#' @name cpp_erode
#' @description
#' This function applies erosion on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Dilatation
#' @name cpp_dilate
#' @description
#' This function applies dilatation on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Opening
#' @name cpp_opening
#' @description
#' This function applies opening on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Closing
#' @name cpp_closing
#' @description
#' This function applies closing on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Morphological Gradient
#' @name cpp_gradient
#' @description
#' This function applies morphological gradient on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image White Top Hat
#' @name cpp_tophat_white
#' @description
#' This function applies white top hat on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Black Top Hat
#' @name cpp_tophat_black
#' @description
#' This function applies black top hat on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Self Complementary Top Hat
#' @name cpp_tophat_self
#' @description
#' This function applies self complementary on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Contrast Enhancement
#' @name cpp_cont
#' @description
#' This function applies contrast enhancement on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Image Laplacian
#' @name cpp_laplacian
#' @description
#' This function applies Laplacian morphology on image.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate/erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Contour Tracing Connected Component Labeling
#' @name cpp_ctl
#' @description
#' This function is designed to identify connected component.
#' @param mat a LogicalMatrix, containing mask.
#' @param global whether to compute the perimeter globally or to evaluate the perimeter of each non 8-connected objects. Default is false.
#' When true pixels of overlapping extra borders of objects are counted only once.
#' @details adaptation of 'A linear-time component-labeling algorithm using contour tracing technique' from F. Change, CJ. Chen and CJ Lu.
#' Computer Vision and Image Understanding Volume 93, Issue 2, February 2004, Pages 206-220.\url{https://doi.org/10.1016/j.cviu.2003.09.002}
#' @return a list whose members are:\cr
#' -matrix: an IntegerMatrix with connected component labels.\cr
#' -contours: an IntegerMatrix of identified contours, whose columns are x, y, label, direction and type.\cr
#' -nb_lab: the total number of components identified.
#' -perimeter: the number of pixels outside contours.
#' @keywords internal
NULL

#' @title Contours Filling
#' @name cpp_fill
#' @description
#' This function is designed to fill contours.
#' @param ctl a List, containing contour tracing labeling, object of class `IFCip_ctl`
#' @param label an uint32_t corresponding to the label of desired set of contour to be filled.
#' Default is 0 to fill all set of contours found.
#' @param inner a bool, to whether or not fill hole(s) inside contours if some where identified
#' @param outer a bool, to whether or not fill contours outside hole(s) if some where identified
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Contours Filling Outer Only
#' @name cpp_fill_out
#' @description
#' This function is designed to fill the most external contours.
#' @param mat an List, containing contour tracing labeling, object of class `IFCip_ctl`
#' @return an IntegerMatrix.
#' @keywords internal
NULL

#' @title Contours Dilatation
#' @name cpp_dilate_ctl
#' @description
#' This function applies contours dilatation.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time dilate should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Contours Erosion
#' @name cpp_erode_ctl
#' @description
#' This function applies contours erosion.
#' @param mat, a NumericMatrix.
#' @param kernel, a NumericMatrix.
#' @param iter, an uint8_t, number of time erode should be iterated. Default is 0.
#' @return a NumericMatrix.
#' @keywords internal
NULL

#' @title Matrix Threshold
#' @name cpp_threshold
#' @description
#' This function takes a image and checks for members superior or equal
#' to max(img) - k * diff(range(img)) / 100 within msk
#' @param img a NumericMatrix
#' @param msk a NumericMatrix
#' @param k constant to be checked. Default is 0.
#' @param removal uint8_t, object removal method. Default is 0 for no removal. Otherwise, if\cr
#' -1, for clipped removal, keep non clipped foreground.\cr
#' -2, height clipped removal.\cr
#' -3, width clipped removal.\cr
#' -4, only keep background:.\cr
#' -5, only keep foreground.
#' @return a logical matrix.
#' @keywords internal
NULL

#' @title Implementation of Zheng-Suen Thinning
#' @name cpp_thinning_zs
#' @description
#' This function is designed to identify mask skeleton.
#' @param mat a LogicalMatrix, containing mask.
#' @details adaptation of 'A fast parallel algorithm for thinning digital patterns' from T. Y. Zhang, C. Y. Suen.
#' Communications of the ACM, March 1984 \url{https://doi.org/10.1145/357994.358023}.
#' @return a LogicalMatrix with the mask thinned.
#' @keywords internal
NULL

#' @title Implementation of Ben Boudaoud-Sider-Tari Thinning
#' @name cpp_thinning_bst
#' @description
#' This function is designed to identify mask skeleton.
#' @param mat a LogicalMatrix, containing mask.
#' @details adaptation of 'A new thinning algorithm for binary images' from L. Ben Boudaoud, A. Sider, A. Tari.
#' 3rd international conference on control, engineering & information technology, May 2015. \url{https://doi.org/10.1109/CEIT.2015.7233099}.
#' @return a LogicalMatrix with the mask thinned.
#' @keywords internal
NULL

#' @title Images Similarity Measurement
#' @name cpp_similarity
#' @description
#' This function is designed to score similarity between two images.
#' @param img1 a NumericMatrix, containing image values.
#' @param img2 a NumericMatrix, containing image values.
#' @param msk a LogicalMatrix, containing mask.
#' @details the similarity is the log transformed Pearson's Correlation Coefficient.
#' It is a measure of the degree to which two images are linearly correlated within a masked region.
#' @return a double, the similarity.
#' @keywords internal
NULL

#' @title Create a Disc
#' @name cpp_make_disc
#' @description
#' This function is designed to create a disc kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Box
#' @name cpp_make_box
#' @description
#' This function is designed to create a box kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Plus
#' @name cpp_make_plus
#' @description
#' This function is designed to create a plus kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Cross
#' @name cpp_make_cross
#' @description
#' This function is designed to create a cross kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Create a Diamond
#' @name cpp_make_diamond
#' @description
#' This function is designed to create a diamond kernel.
#' @param size, a uint8_t of the desired kernel size.
#' @return a LogicalMatrix.
#' @keywords internal
NULL

#' @title Convex Hull
#' @name cpp_convexhull
#' @description
#' Computes 2D convex hull of a set of points.
#' @param pts a 2-column matrix defining the locations (x and y coordinates, respectively) of points.
#' x has to be in column 0 and y in column 1 (C index, add 1 for R).
#' @return a vector of row indices of 'pts' that constitutes convex hull vertices.
#' @source Adaptation of Andrew's Monotone Chain Algorithm A. M. Andrew, 'Another Efficient Algorithm
#' for Convex Hulls in Two Dimension', Information Processing Letters, 9, 1979, pp216-219 reported
#' in M. A. Jayaram, Hasan Fleyeh, 'Convex Hulls in Image Processing: A Scoping Review', 
#' American Journal of Intelligent Systems, Vol. 6 No. 2, 2016, pp. 48-58.
#' @keywords internal
NULL

cpp_background <- function(img, margin = 4L, extra = 0L, is_cif = FALSE) {
    .Call(`_IFCip_cpp_background`, img, margin, extra, is_cif)
}

cpp_antipodalpairs <- function(pts) {
    .Call(`_IFCip_cpp_antipodalpairs`, pts)
}

#' @title Bounding Box of Convex Hull
#' @name cpp_bbox
#' @description
#' Computes features from a Convex Hull 
#' @param pts a 2-column matrix defining the locations (x and y coordinates, respectively) of points.
#' It has to be an object of class `IFCip_convexhull`
#' @param scale a double used to scale the returned values.
#' @return a NumericVector of features from convex hull.
#' @keywords internal
cpp_bbox <- function(pts, scale = 1.0) {
    .Call(`_IFCip_cpp_bbox`, pts, scale)
}

cpp_R_shift_M <- function(mat, bits = 4L) {
    .Call(`_IFCip_cpp_R_shift_M`, mat, bits)
}

cpp_rescale_M <- function(mat, bits = 4L) {
    .Call(`_IFCip_cpp_rescale_M`, mat, bits)
}

cpp_cooc <- function(img, msk, delta = 1L) {
    .Call(`_IFCip_cpp_cooc`, img, msk, delta)
}

cpp_h_features <- function(cooc, invariant = FALSE) {
    .Call(`_IFCip_cpp_h_features`, cooc, invariant)
}

cpp_centroid <- function(img) {
    .Call(`_IFCip_cpp_centroid`, img)
}

cpp_rmoment <- function(img, p = 0L, q = 0L) {
    .Call(`_IFCip_cpp_rmoment`, img, p, q)
}

cpp_cmoment <- function(img, cx = 0.0, cy = 0.0, p = 0L, q = 0L) {
    .Call(`_IFCip_cpp_cmoment`, img, cx, cy, p, q)
}

cpp_features_hu1 <- function(img, mag = 1.0) {
    .Call(`_IFCip_cpp_features_hu1`, img, mag)
}

cpp_features_hu2 <- function(img, mag = 1.0) {
    .Call(`_IFCip_cpp_features_hu2`, img, mag)
}

cpp_basic <- function(img, msk, mag = 1.0) {
    .Call(`_IFCip_cpp_basic`, img, msk, mag)
}

cpp_features_hu3 <- function(img, msk, components = 0L, mag = 1.0) {
    .Call(`_IFCip_cpp_features_hu3`, img, msk, components, mag)
}

cpp_distance_eucl <- function(msk) {
    .Call(`_IFCip_cpp_distance_eucl`, msk)
}

cpp_distance_eucl_norm <- function(msk) {
    .Call(`_IFCip_cpp_distance_eucl_norm`, msk)
}

cpp_distance_manh <- function(msk) {
    .Call(`_IFCip_cpp_distance_manh`, msk)
}

cpp_distance_manh_norm <- function(msk) {
    .Call(`_IFCip_cpp_distance_manh_norm`, msk)
}

cpp_disttrans_manh <- function(img) {
    .Call(`_IFCip_cpp_disttrans_manh`, img)
}

cpp_disttrans_eucl <- function(img) {
    .Call(`_IFCip_cpp_disttrans_eucl`, img)
}

cpp_voronoi_eucl <- function(img) {
    .Call(`_IFCip_cpp_voronoi_eucl`, img)
}

cpp_voronoi_manh <- function(img) {
    .Call(`_IFCip_cpp_voronoi_manh`, img)
}

cpp_watershed <- function(mat, connectivity = 8L, levels = 256L) {
    .Call(`_IFCip_cpp_watershed`, mat, connectivity, levels)
}

cpp_zernike1 <- function(img, cx, cy, nmax = 15L, radius = 15.0) {
    .Call(`_IFCip_cpp_zernike1`, img, cx, cy, nmax, radius)
}

cpp_zernike2 <- function(img, cx, cy, nmax = 15L, radius = 15.0) {
    .Call(`_IFCip_cpp_zernike2`, img, cx, cy, nmax, radius)
}

cpp_AND_M <- function(list) {
    .Call(`_IFCip_cpp_AND_M`, list)
}

cpp_OR_M <- function(list) {
    .Call(`_IFCip_cpp_OR_M`, list)
}

cpp_NEG_M <- function(mat) {
    .Call(`_IFCip_cpp_NEG_M`, mat)
}

cpp_k_equal_M <- function(mat, k = 3.0) {
    .Call(`_IFCip_cpp_k_equal_M`, mat, k)
}

cpp_k_sup_equal_M <- function(mat, k = 3.0) {
    .Call(`_IFCip_cpp_k_sup_equal_M`, mat, k)
}

cpp_k_inf_equal_M <- function(mat, k = 3.0) {
    .Call(`_IFCip_cpp_k_inf_equal_M`, mat, k)
}

cpp_shift <- function(mat, d_row = 0L, d_col = 0L, add_noise = TRUE, bg = 0.0, sd = 0.0) {
    .Call(`_IFCip_cpp_shift`, mat, d_row, d_col, add_noise, bg, sd)
}

cpp_flip <- function(mat, which = TRUE) {
    .Call(`_IFCip_cpp_flip`, mat, which)
}

cpp_padding <- function(mat, kernel, method = 1L, k = 0.0) {
    .Call(`_IFCip_cpp_padding`, mat, kernel, method, k)
}

cpp_sd <- function(mat, kernel) {
    .Call(`_IFCip_cpp_sd`, mat, kernel)
}

cpp_median <- function(mat, kernel) {
    .Call(`_IFCip_cpp_median`, mat, kernel)
}

cpp_mode <- function(mat, kernel) {
    .Call(`_IFCip_cpp_mode`, mat, kernel)
}

cpp_mid <- function(mat, kernel) {
    .Call(`_IFCip_cpp_mid`, mat, kernel)
}

cpp_convolve2d <- function(mat, kernel) {
    .Call(`_IFCip_cpp_convolve2d`, mat, kernel)
}

cpp_correlate2d <- function(mat, kernel) {
    .Call(`_IFCip_cpp_correlate2d`, mat, kernel)
}

cpp_erode <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_erode`, mat, kernel, iter)
}

cpp_dilate <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_dilate`, mat, kernel, iter)
}

cpp_opening <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_opening`, mat, kernel, iter)
}

cpp_closing <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_closing`, mat, kernel, iter)
}

cpp_gradient <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_gradient`, mat, kernel, iter)
}

cpp_tophat_white <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_tophat_white`, mat, kernel, iter)
}

cpp_tophat_black <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_tophat_black`, mat, kernel, iter)
}

cpp_tophat_self <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_tophat_self`, mat, kernel, iter)
}

cpp_cont <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_cont`, mat, kernel, iter)
}

cpp_laplacian <- function(mat, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_laplacian`, mat, kernel, iter)
}

cpp_ctl <- function(mat, global = FALSE) {
    .Call(`_IFCip_cpp_ctl`, mat, global)
}

cpp_fill <- function(ctl, label = 0L, inner = TRUE, outer = TRUE) {
    .Call(`_IFCip_cpp_fill`, ctl, label, inner, outer)
}

cpp_fill_out <- function(ctl) {
    .Call(`_IFCip_cpp_fill_out`, ctl)
}

cpp_dilate_ctl <- function(ctl, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_dilate_ctl`, ctl, kernel, iter)
}

cpp_erode_ctl <- function(ctl, kernel, iter = 0L) {
    .Call(`_IFCip_cpp_erode_ctl`, ctl, kernel, iter)
}

cpp_threshold <- function(img, msk, k = 0.0, removal = 0L) {
    .Call(`_IFCip_cpp_threshold`, img, msk, k, removal)
}

cpp_thinning_zs <- function(mat) {
    .Call(`_IFCip_cpp_thinning_zs`, mat)
}

cpp_thinning_bst <- function(mat) {
    .Call(`_IFCip_cpp_thinning_bst`, mat)
}

cpp_similarity <- function(img1, img2, msk) {
    .Call(`_IFCip_cpp_similarity`, img1, img2, msk)
}

cpp_make_disc <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_disc`, size)
}

cpp_make_box <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_box`, size)
}

cpp_make_plus <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_plus`, size)
}

cpp_make_cross <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_cross`, size)
}

cpp_make_diamond <- function(size = 3L) {
    .Call(`_IFCip_cpp_make_diamond`, size)
}

cpp_convexhull <- function(pts) {
    .Call(`_IFCip_cpp_convexhull`, pts)
}

